9 Oct 2016:
	didnt write the first 2 days' worth :(
	pretty easy to include, just point to the SDK's lib and includes, and 
	you're ready to use vulkan, no extension wranglers that i know of yet
	by the way, its following this https://vulkan-tutorial.com
	vk is meant to be a "car with a manual gearbox", you could screw it up 
	really badly, or make it more efficient
	to ease the use of this manual mode, you've got validation layers
	they're completely. you don't have to use them, but you'd look like 
	a prick if you didn't

10 Oct 2016:
	update your video card drivers you nutwit, validation layers wont work
	with your half-a-year-old drivers

11 Oct 2016:
	debug report callbacks with validation layers all set up and ready
	i dont understand them, neither do you
	almost everything done in vulkan is submitted into a command queue for
	sequential execution, better multithread work handling (hopefully)
	funcs to find a decent graphics card for vk to use

12 Oct 2016:
	logical device creation
	you can specify the command queue priority in your vk object, from 0 to 1
	just like OGL, its context needs a window handle to display to, we'll use
	GLFW, but SDL can be used, it's just not officially supported, but there's
	a library out there that eases its use with VK
	window surface needs to be created right after vkinstance creation, but
	there's a lot to cover regarding render targets etc.
	unlike opengl, you can do background rendering without using cheap hacks
	like making an invisible window
	the surface needs to find a good parent, aka queue family to adopt it
	nvidia cards allegedly support ~16 queue families, while
	AMD supports ~4+, and intel just 1
	use as many as possible, according to stack overflow answers
	https://www.reddit.com/r/vulkan/comments/46ckoc/queue_families/

13 Oct 2016:
	swap chains must be explicitly configured in VK, "thanks"
	then you choose the most appropriate pixel format to render as a surface
	presentation mode, gotta do that manually too, well it's kinda standard
	anyway, aka, whether you want doublebuffering/vsync
	
14 Oct 2016:
	fixed external link errors - vdeleter didnt work properly, likely the
	separately defined multi-template functions

15 Oct 2016:
	image views. in order to use any VkImage, like those in the swap chain,
	we have to make a VkImageView obj. literally a view onto the image
	it describes how to access the image and which part of the image to access
	eg. if it should just be treated like only its depth map existed
	a pure image view isnt totally suitable for setting as a render target
	yet though, we'd still need a framebuffer! doh

16 Oct 2016:
	shader pipelines - you specify what you need! dont need tesselation
	shaders? just omit it in the setup process, more tedius, but fine tuned
	unlike ogl, you have to precompile your shader code to bytecode :(
	(the SPIR-V format, used by VK and OCL)
	the VK SDK has a glsl-to-spir-v compiler, @ glslangValidator.exe
	in case you're an idiot and forgot about how shaders in glsl work,
	main() gets invoked per object (eg vertex, fragment), and you don't pass
	any parameters into main(), but are handled via global variables in your
	code. it's got built-in vector and matrix primitives
	if you're just pasting coordinates onto your screen, it would be
	on the framebuffer: 0px to 1920px (eg), and -1 to +1 on your clip coords,
	by the way, vulkan flipped the Y coords on clip space, so y=-1 is up top,
	and the Z value follows directX now, from 0 to 1 (dont need to manually
	inverse for better precision, like in opengl, yeah buddy)
	vertex buffers are tedious to set up on VK, so its gonna be postponed :(
	made a cute little bat file to compile them using the aforementioned
	compiler
